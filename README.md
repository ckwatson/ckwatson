CKWatson Online
===============
[![JavaScript Style Guide](https://img.shields.io/badge/code_style-standard-brightgreen.svg)](https://standardjs.com)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
[![pre-commit](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white)](https://github.com/pre-commit/pre-commit)
[![uv](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/astral-sh/uv/main/assets/badge/v0.json)](https://github.com/astral-sh/uv)

A Chemical Kinetics Simulator Game as a webapp, written in Python.

![Screenshot](http://i.imgur.com/UVizS1S.png)

## Installation

```shell
git clone https://github.com/ckwatson/web_gui.git
cd web_gui
git submodule update --init --recursive
uv sync
```

## Setup

To run CKWatson with Redis and gunicorn:

1. In one terminal, execute `redis-server`.
2. Then, in another terminal: `just run`.

_Alternatively_, you can run the boot script directly: `uv run run.py`.

This uses Flask itself to host the server, but would lose the ability to send [Server-Sent Events](https://github.com/singingwolfboy/flask-sse).

## Deployment

### Via Docker

You can either run CKWatson as a single container or with Redis using Docker Compose.

To run CKWatson as a single container:
1. Build the image: `docker build -t ckw .`
2. Start a container: `docker run -p 80:80 --rm --name ckwatson ckw`

To run CKWatson with Redis, simply use `docker-compose up`.

### Via Kubernetes

I will be using [minikube](https://minikube.sigs.k8s.io/) in this walkthrough. I will be using the local Docker Registry as the source of the Kubenetes image.

```shell
# Start the cluster:
minikube start
# Register the Docker Registry to minikube -- This is because we will be building the image from the Dockerfile for Kubenetes:
eval $(minikube docker-env)
# Build the Docker image for Kubenetes:
docker build -t ckw .
# Apply the Deployment (which manages the Pods/"virtual hosts" in the minikube cluster for the app) as well as the Service (which is a Load Balancer in this case that exposes the web app in the Pods) using the manifest file:
kubectl apply -f ./k8s
# Access the web app:
minikube service web
```

### On Heroku

Please use [this Buildpack](https://github.com/dmathieu/heroku-buildpack-submodules#installation) for Auto-Deployment Support on submodules.


## Folder Structure

- `kernel` is where the actual code are stored.
- `puzzles` is the repository of puzzle definitions. Admin can add puzzles there using the `create` page.
- `web` stores the server program for web-based GUI. It translates user inputs into codes that the `kernel` could understand.
- `results` stores the computed results as well as plotted figures generated by the `kernel`. Not really human-readable.
